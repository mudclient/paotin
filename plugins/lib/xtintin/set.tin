#nop vim: set filetype=tt:;

/*
æœ¬æ–‡ä»¶å±äº PaoTin++ çš„ä¸€éƒ¨åˆ†ã€‚
PaoTin++ Â© 2020~2023 çš„æ‰€æœ‰ç‰ˆæƒå‡ç”±æ‹…å­ç‚®(dzp <danzipao@gmail.com>) äº«æœ‰å¹¶ä¿ç•™ä¸€åˆ‡æ³•å¾‹æƒåˆ©
ä½ å¯ä»¥åœ¨éµç…§ GPLv3 åè®®çš„åŸºç¡€ä¹‹ä¸Šä½¿ç”¨ã€ä¿®æ”¹åŠé‡æ–°åˆ†å‘æœ¬ç¨‹åºã€‚
*/

#nop æœ¬æ–‡ä»¶æ˜¯ xtintin çš„ä¸€éƒ¨åˆ†ï¼Œå®ç°äº†ä¸€äº›é›†åˆå¤„ç†å‡½æ•°;

///=== {
///// é›†åˆå¤„ç†å‡½æ•°ï¼š
/////
///// é›†åˆåœ¨ TinTin++ ä¸­å¹¶æ— åŸç”Ÿæ¦‚å¿µå¯¹åº”ï¼ŒPaoTin++ ä¸­çš„é›†åˆç”¨ #list æ¥å®ç°ï¼Œä¿è¯æ¯ä¸ªå…ƒç´ éƒ½ä¸ç›¸åŒã€‚
///// ä¹Ÿå°±æ˜¯è¯´ï¼Œæ— è®ºæ˜¯å¯¹é›†åˆè¿›è¡Œä½•ç§è¿ç®—ï¼Œé‡å¤å…ƒç´ åœ¨é›†åˆä¸­åªä¼šå‡ºç°ä¸€æ¬¡ã€‚
/////
///// ç”±äº PaoTin++ ä¸­æ˜¯ç”¨ #list æ¥å­˜å‚¨ setï¼Œå› æ­¤ #list ç›¸å…³çš„å‘½ä»¤å’Œ xtintin API éƒ½å¯ä»¥ç”¨äºé›†åˆã€‚
//
// #@ set.Create <å…ƒç´ > [...]
//    åˆ©ç”¨æä¾›çš„å¤šä¸ªå…ƒç´ åˆ›å»ºæ–°é›†åˆã€‚
// };
#func {set.Create} {
    #return {@set.Add{{};%0}};
};

///=== {
// #@ set.FromList <åˆ—è¡¨>
//    å°†åˆ—è¡¨è½¬æ¢æˆé›†åˆã€‚
// };
#func {set.FromList} {
    #local list {%0};
    #return {@set.Add{{};$list[%*]}};
};

///=== {
// #@ set.Size <é›†åˆ>
//    è®¡ç®—é›†åˆçš„å…ƒç´ æ•°é‡ã€‚
// };
#func {set.Size} {
    #local set {%0};
    #return &set[];
};

///=== {
// #@ set.Contains <é›†åˆ> <å…ƒç´ >
//    åˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ã€‚
// };
#func {set.Contains} {
    #info arguments save;
    #local set  {$info[ARGUMENTS][1]};
    #local elem {$info[ARGUMENTS][2]};

    #if { @list.IndexOf{{$set};{$elem}} > 0 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ set.Add <é›†åˆ> <å…ƒç´ > [...]
//    å°†ä¸€ä¸ªæˆ–è€…å¤šä¸ªå…ƒç´ æ·»åŠ åˆ°é›†åˆå½“ä¸­ã€‚
// };
#func {set.Add} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local elem {$argv[+$idx]};
        #if { !@set.Contains{{$set};{$elem}} } {
            #list set {add} {{$elem}};
        };
    };

    #return {$set};
};

///=== {
// #@ set.Remove <é›†åˆ> <å…ƒç´ > [...]
//    ä»é›†åˆä¸­åˆ é™¤ä¸€ä¸ªæˆ–è€…å¤šä¸ªå…ƒç´ ã€‚
// };
#func {set.Remove} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local elem {$argv[+$idx]};
        #local idx @list.IndexOf{{$set};{$elem}};
        #if { $idx > 0 } {
            #list set {delete} {$idx};
        };
    };

    #return {$set};
};

///=== {
// #@ set.Equal <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ1å’Œé›†åˆ2æ˜¯å¦ç›¸ç­‰ã€‚
//    ğŸ“–  å¦‚æœä¸¤ä¸ªé›†åˆä¸­åŒ…å«çš„å…ƒç´ æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆå°±åˆ¤å®šä¸ºç›¸ç­‰ã€‚ç›¸ç­‰åˆ¤å®šå¹¶ä¸è¦æ±‚å…ƒç´ é¡ºåºç›¸åŒã€‚
// };
#func {set.Equal} {
    #local set1  {%1};
    #local set2  {%2};

    #if { @set.IsSubset{{$set1};{$set2}} && &set1[] == &set2[] } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ set.IsSubset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„å­é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ1åŒ…å«äº†é›†åˆ2ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„å­é›†ã€‚
// };
#func {set.IsSubset} {
    #local set1  {%1};
    #local set2  {%2};

    #local idx {0};
    #foreach {*set2[]} {idx} {
        #if { !@set.Contains{{$set1};{$set2[$idx]}} } {
            #return 0;
        };
    };

    #return 1;
};

///=== {
// #@ set.IsProperSubset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„çœŸå­é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ1åŒ…å«äº†é›†åˆä¸­2çš„æ¯ä¸ªå…ƒç´ ï¼Œè€Œä¸”é›†åˆ1æ¯”é›†åˆ2çš„å…ƒç´ è¿˜è¦å¤šï¼Œ
//       é‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„çœŸå­é›†ã€‚
// };
#func {set.IsProperSubset} {
    #local set1  {%1};
    #local set2  {%2};

    #if { @set.IsSubset{{$set1};{$set2}} && &set1[] > &set2[] } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ set.IsSuperset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„è¶…é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ2åŒ…å«äº†é›†åˆ1ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„è¶…é›†ã€‚
// };
#func {set.IsSuperset} {
    #return {@set.IsSubset{{%2};{%1}}};
};

///=== {
// #@ set.IsProperSuperset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„çœŸè¶…é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ2åŒ…å«äº†é›†åˆä¸­1çš„æ¯ä¸ªå…ƒç´ ï¼Œè€Œä¸”é›†åˆ2æ¯”é›†åˆ1çš„å…ƒç´ è¿˜è¦å¤šï¼Œ
//       é‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„çœŸè¶…é›†ã€‚
// };
#func {set.IsProperSuperset} {
    #return {@set.IsProperSubset{{%2};{%1}}};
};

///=== {
// #@ set.Union <é›†åˆ1> <é›†åˆ2> [...]
//    æ±‚ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„å¹¶é›†ã€‚
//    ğŸ“–  å¹¶é›†æ˜¯æŒ‡æŠŠæ‰€æœ‰é›†åˆå…ƒç´ æ”¾åœ¨ä¸€å—å„¿ä¹‹åå¾—åˆ°çš„æ–°é›†åˆã€‚
// };
#func {set.Union} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local other {$argv[+$idx]};
        #local set {@set.Add{{$set};$other[%*]}};
    };

    #return {$set};
};

///=== {
// #@ set.Intersection <é›†åˆ1> <é›†åˆ2> [...]
//    æ±‚ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„äº¤é›†ã€‚
//    ğŸ“–  äº¤é›†æ˜¯æŒ‡ç”±åŒæ—¶å‡ºç°åœ¨æ‰€æœ‰é›†åˆä¸­çš„å…ƒç´ ç»„æˆçš„æ–°é›†åˆã€‚
// };
#func {set.Intersection} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {};
    };

    #local set  {$argv[1]};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #if { &set[] == 0 } {
            #return {};
        };

        #local other {$argv[+$idx]};
        #loop {&set[]} {1} {idx} {
            #local elem {$set[$idx]};
            #if { !@set.Contains{{$other};{$elem}} } {
                #list set {delete} {$idx};
            };
        };
    };

    #return {$set};
};

///=== {
// #@ set.IsDisjoint <é›†åˆ1> <é›†åˆ2> [...]
//    åˆ¤æ–­ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆæ˜¯å¦ä¸ºä¸äº¤é›†ã€‚
//    ğŸ“–  ä¸äº¤é›†æ˜¯äº¤é›†ä¸ºç©ºçš„æ„æ€ã€‚
// };
#func {set.IsDisjoint} {
    #local set {@set.Intersection{%0}};
    #if { &set[] == 0 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ set.Product <é›†åˆ1> <é›†åˆ2> [...]
//    è®¡ç®—ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯ã€‚è¿”å›ç»“æœé›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼Œ
//    å…¶å€¼åˆ†åˆ«æ¥è‡ªå„ä¸ªå‚æ•°é›†åˆçš„å…ƒç´ ã€‚
//    ğŸ“–  ä¸¤ä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯æ˜¯æŒ‡ç”±ä¸¤ä¸ªé›†åˆçš„å…ƒç´ ç»„æˆçš„æ‰€æœ‰å¯èƒ½çš„æœ‰åºå¯¹çš„é›†åˆã€‚
//       å¤šä¸ªé›†åˆçš„ç§¯ä¹Ÿå¯ç”±æ­¤æ‰©å±•ã€‚
// };
#func {set.Product} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {};
    };

    #local set  {$argv[1]};
    #if { &set[] == 0 } {
        #return {};
    };

    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local other {$argv[+$idx]};
        #if { &other[] == 0 } {
            #return {};
        };

        #local newSet {};
        #local left {};
        #local right {};
        #loop {1} {&set[]} {left} {
            #local left {$set[+$left]};
            #loop {1} {&other[]} {right} {
                #local right {$other[+$right]};
                #list newSet {add} {{$left;$right}};
            };
        };

        #local set {$newSet};
    };

    #return {$set};
};

///=== {
// #@ set.Diff <é›†åˆ1> <é›†åˆ2> [...]
//    è®¡ç®—é›†åˆ1ä¸å…¶å®ƒé›†åˆçš„ç›¸å¯¹å·®ã€‚
//    ğŸ“–  ç›¸å¯¹å·®æ˜¯æŒ‡ä»é›†åˆ1ä¸­å»æ‰æ‰€æœ‰åœ¨å…¶å®ƒé›†åˆä¸­å‡ºç°è¿‡çš„å…ƒç´ ä¹‹åå‰©ä¸‹çš„é›†åˆã€‚
// };
#func {set.Diff} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #if { &set[] == 0 } {
            #return {};
        };

        #local other {$argv[+$idx]};
        #local set {@set.Remove{{$set};$other[%*]}};
    };

    #return {$set};
};

///=== {
// #@ set.SymmDiff <é›†åˆ1> <é›†åˆ2>
//    è®¡ç®—é›†åˆ1ä¸é›†åˆ2çš„å¯¹ç§°å·®ã€‚
//    ğŸ“–  å¯¹ç§°å·®æ˜¯æŒ‡å¹¶é›†ä¸äº¤é›†çš„ç›¸å¯¹å·®ã€‚
// };
#func {set.SymmDiff} {
    #return {@set.Diff{{@set.Union{{%1};{%2}}};{@set.Intersection{{%1};{%2}}}}};
};

///=== {
///// ä¸‹é¢è¿™ä¸€ç»„ API é‡‡ç”¨å­—ç¬¦ä¸²åˆ—è¡¨æ¥ä½œä¸ºé›†åˆè¡¨è¾¾ã€‚åŠŸèƒ½ä¸ä¸Šé¢ç›¸åŒã€‚åªæ˜¯æ•°æ®ç±»å‹ä¸ä¸€æ ·ã€‚
///// ä¸ºäº†å’Œä¸Šé¢ä»¥ç¤ºåŒºåˆ†ï¼Œå‰ç¼€ set æ”¹ä¸º ssetï¼Œæ„æŒ‡ string setã€‚
//
// #@ sset.Create <å­—ç¬¦ä¸²åˆ—è¡¨>
//    ä»å­—ç¬¦ä¸²åˆ—è¡¨åˆ›å»ºé›†åˆã€‚
// };
#func {sset.Create} {
    #return {@sset.Add{{};%0}};
};

///=== {
// #@ sset.Size <é›†åˆ>
//    è®¡ç®—é›†åˆçš„å…ƒç´ æ•°é‡ã€‚
// };
#func {sset.Size} {
    #return {@slist.Size{%0}};
};

///=== {
// #@ sset.Contains <é›†åˆ> <å…ƒç´ >
//    åˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨é›†åˆä¸­ã€‚
// };
#func {sset.Contains} {
    #info arguments save;
    #local set  {$info[ARGUMENTS][1]};
    #local elem {$info[ARGUMENTS][2]};

    #if { @slist.IndexOf{{$set};{$elem}} > 0 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ sset.Add <é›†åˆ> <å…ƒç´ > [...]
//    å°†ä¸€ä¸ªæˆ–è€…å¤šä¸ªå…ƒç´ æ·»åŠ åˆ°é›†åˆå½“ä¸­ã€‚
// } ;
#func {sset.Add} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #return {@slist.FromList{@set.Add{{@list.FromSlist{$set}};$argv[2..-1]}}};
};

///=== {
// #@ sset.Remove <é›†åˆ> <å…ƒç´ > [...]
//    ä»é›†åˆä¸­åˆ é™¤ä¸€ä¸ªæˆ–è€…å¤šä¸ªå…ƒç´ ã€‚
// };
#func {sset.Remove} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {$argv[1]};
    #return {@slist.FromList{@set.Remove{{@list.FromSlist{$set}};$argv[2..-1]}}};
};

///=== {
// #@ sset.Equal <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ1å’Œé›†åˆ2æ˜¯å¦ç›¸ç­‰ã€‚
//    ğŸ“–  å¦‚æœä¸¤ä¸ªé›†åˆä¸­åŒ…å«çš„å…ƒç´ æ˜¯ç›¸åŒçš„ï¼Œé‚£ä¹ˆå°±åˆ¤å®šä¸ºç›¸ç­‰ã€‚ç›¸ç­‰åˆ¤å®šå¹¶ä¸è¦æ±‚å…ƒç´ é¡ºåºç›¸åŒã€‚
// };
#func {sset.Equal} {
    #local set1  {%1};
    #local set2  {%2};

    #if { @sset.IsSubset{{$set1};{$set2}} && @slist.Size{$set1} == @slist.Size{$set2} } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ sset.IsSubset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„å­é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ1åŒ…å«äº†é›†åˆ2ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„å­é›†ã€‚
// };
#func {sset.IsSubset} {
    #local set1  {%1};
    #local set2  {%2};

    #local elem {0};
    #foreach {$set2} {elem} {
        #if { !@sset.Contains{{$set1};{$elem}} } {
            #return 0;
        };
    };

    #return 1;
};

///=== {
// #@ sset.IsProperSubset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„çœŸå­é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ1åŒ…å«äº†é›†åˆä¸­2çš„æ¯ä¸ªå…ƒç´ ï¼Œè€Œä¸”é›†åˆ1æ¯”é›†åˆ2çš„å…ƒç´ è¿˜è¦å¤šï¼Œ
//       é‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„çœŸå­é›†ã€‚
// };
#func {sset.IsProperSubset} {
    #local set1  {%1};
    #local set2  {%2};

    #if { @sset.IsSubset{{$set1};{$set2}} && @slist.Size{$set1} > @slist.Size{$set2} } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ sset.IsSuperset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„è¶…é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ2åŒ…å«äº†é›†åˆ1ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„è¶…é›†ã€‚
// };
#func {sset.IsSuperset} {
    #return {@sset.IsSubset{{%2};{%1}}};
};

///=== {
// #@ sset.IsProperSuperset <é›†åˆ1> <é›†åˆ2>
//    åˆ¤æ–­é›†åˆ2æ˜¯å¦ä¸ºé›†åˆ1çš„çœŸè¶…é›†ã€‚
//    ğŸ“–  å¦‚æœé›†åˆ2åŒ…å«äº†é›†åˆä¸­1çš„æ¯ä¸ªå…ƒç´ ï¼Œè€Œä¸”é›†åˆ2æ¯”é›†åˆ1çš„å…ƒç´ è¿˜è¦å¤šï¼Œ
//       é‚£ä¹ˆé›†åˆ2å°±æ˜¯é›†åˆ1çš„çœŸè¶…é›†ã€‚
// };
#func {sset.IsProperSuperset} {
    #return {@sset.IsProperSubset{{%2};{%1}}};
};

///=== {
// #@ sset.Union <é›†åˆ1> <é›†åˆ2> [...]
//    æ±‚ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„å¹¶é›†ã€‚
//    ğŸ“–  å¹¶é›†æ˜¯æŒ‡æŠŠæ‰€æœ‰é›†åˆæ”¾åœ¨ä¸€å—å„¿ä¹‹åå¾—åˆ°çš„æ–°é›†åˆã€‚
// };
#func {sset.Union} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {@list.FromSlist{$argv[1]}};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local other {$argv[+$idx]};
        #local set {@set.Add{{$set};$other}};
    };

    #return {@slist.FromList{$set}};
};

///=== {
// #@ sset.Intersection <é›†åˆ1> <é›†åˆ2> [...]
//    æ±‚ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„äº¤é›†ã€‚
//    ğŸ“–  äº¤é›†æ˜¯æŒ‡ç”±åŒæ—¶å‡ºç°åœ¨æ‰€æœ‰é›†åˆä¸­çš„å…ƒç´ ç»„æˆçš„æ–°é›†åˆã€‚
// };
#func {sset.Intersection} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {};
    };

    #local set  {@list.FromSlist{$argv[1]}};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #if { &set[] == 0 } {
            #return {};
        };

        #local other {$argv[+$idx]};
        #loop {&set[]} {1} {idx} {
            #local elem {$set[$idx]};
            #if { !@sset.Contains{{$other};{$elem}} } {
                #list set {delete} {$idx};
            };
        };
    };

    #return {@slist.FromList{$set}};
};

///=== {
// #@ sset.IsDisjoint <é›†åˆ1> <é›†åˆ2> [...]
//    åˆ¤æ–­ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆæ˜¯å¦ä¸ºä¸äº¤é›†ã€‚
//    ğŸ“–  ä¸äº¤é›†æ˜¯äº¤é›†ä¸ºç©ºçš„æ„æ€ã€‚
// };
#func {sset.IsDisjoint} {
    #local set {@sset.Intersection{%0}};
    #if { @slist.Size{$set} == 0 } {
        #return 1;
    };
    #else {
        #return 0;
    };
};

///=== {
// #@ sset.Product <é›†åˆ1> <é›†åˆ2> [...]
//    è®¡ç®—ä¸¤ä¸ªæˆ–è€…å¤šä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯ã€‚è¿”å›ç»“æœé›†åˆä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œ
//    å…¶å€¼ç”±å„ä¸ªå‚æ•°é›†åˆçš„å…ƒç´ æ‹¼æ¥è€Œæˆã€‚
//    å¦‚æœè°ƒç”¨å‰è®¾ç½®äº†ç¯å¢ƒå˜é‡ sset-product-dividerï¼Œåˆ™ä¼šä»¥å®ƒä¸ºåˆ†éš”ç¬¦æ‹¼æ¥ã€‚
//    <171>æ³¨æ„<299>ï¼Œsset-product-divider ä¸èƒ½è¢«è®¾ç½®ä¸ºåˆ†å·ï¼Œè¿™ä¼šå¯¼è‡´ç¾éš¾æ€§çš„åæœã€‚
//    ğŸ“–  ä¸¤ä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯æ˜¯æŒ‡ç”±ä¸¤ä¸ªé›†åˆçš„å…ƒç´ ç»„æˆçš„æ‰€æœ‰å¯èƒ½çš„æœ‰åºå¯¹çš„é›†åˆã€‚
//       å¤šä¸ªé›†åˆçš„ç§¯ä¹Ÿå¯ç”±æ­¤æ‰©å±•ã€‚
// };
#func {sset.Product} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {};
    };

    #local set  {@list.FromSlist{$argv[1]}};
    #if { &set[] == 0 } {
        #return {};
    };

    #local divider {@defaultVar{$sset-product-divider}};

    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #local other {$argv[+$idx]};
        #if { "$other" == "" } {
            #return {};
        };

        #local newSet {};
        #local left {};
        #local right {};
        #loop {1} {&set[]} {left} {
            #local left {$set[+$left]};
            #foreach {$other} {right} {
                #list newSet {add} {{$left$divider$right}};
            };
        };

        #local set {$newSet};
    };

    #return {@slist.FromList{$set}};
};

///=== {
// #@ sset.Diff <é›†åˆ1> <é›†åˆ2> [...]
//    è®¡ç®—é›†åˆ1ä¸å…¶å®ƒé›†åˆçš„ç›¸å¯¹å·®ã€‚
//    ğŸ“–  ç›¸å¯¹å·®æ˜¯æŒ‡ä»é›†åˆ1ä¸­å»æ‰æ‰€æœ‰åœ¨å…¶å®ƒé›†åˆä¸­å‡ºç°è¿‡çš„å…ƒç´ ä¹‹åå‰©ä¸‹çš„é›†åˆã€‚
// };
#func {sset.Diff} {
    #info arguments save;
    #unvar info[ARGUMENTS][0];
    #local argv {$info[ARGUMENTS]};

    #if { &argv[] < 2 } {
        #return {$argv[1]};
    };

    #local set  {@list.FromSlist{$argv[1]}};
    #local idx  {0};
    #loop {2} {&argv[]} {idx} {
        #if { &set[] == 0 } {
            #return {};
        };

        #local other {$argv[+$idx]};
        #local set {@set.Remove{{$set};$other}};
    };

    #return {@slist.FromList{$set}};
};

///=== {
// #@ sset.SymmDiff <é›†åˆ1> <é›†åˆ2>
//    è®¡ç®—é›†åˆ1ä¸é›†åˆ2çš„å¯¹ç§°å·®ã€‚
//    ğŸ“–  å¯¹ç§°å·®æ˜¯æŒ‡å¹¶é›†ä¸äº¤é›†çš„ç›¸å¯¹å·®ã€‚
// };
#func {sset.SymmDiff} {
    #return {@sset.Diff{{@sset.Union{{%1};{%2}}};{@sset.Intersection{{%1};{%2}}}}};
};
