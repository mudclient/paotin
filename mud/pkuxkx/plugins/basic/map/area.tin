#nop vim: set filetype=tt:;

/*
本文件属于 PaoTin++ 的一部分
===========
PaoTin++ © 2020~2023 的所有版权均由担子炮(dzp <danzipao@gmail.com>) 享有并保留一切法律权利
你可以在遵照 GPLv3 协议的基础之上使用、修改及重新分发本程序。
===========
*/

///=== {
///// map/area --- 大众版区域信息获取模块
/////
///// 本模块主要使用 walk 和 localmaps 两个常用命令。
///// };

VAR {全局区域对照表} {map.area.dict} {};

event.Define {map/GotArea}      {无参} {$MODULE} {已经获取到区域信息，并更新到 gMapRoom 全局变量。};
event.Define {map/GotLocalmaps} {无参} {$MODULE} {已经解析 localmaps 命令。};

event.HandleOnce {map/init} {map/area} {map} {pkuxkx.map.area.init};

#alias {pkuxkx.map.area.init} {
    set localmap;
    storage.Load {map-area} {map.area.dict};
};

///=== {
// ## map.GetArea
//    弄清楚角色当前位于哪个区域。
//    注意调查过程中可能会向服务器发送必要的命令（尽可能少地）。但如果角色正在移动，则不会发送任何命令。
//    弄清楚之后，发送事件 map/GotArea。
//    注意如果已经弄清楚了，则不会发送事件。因此建议先通过函数 map.GetArea 进行查询。
// };
#alias {map.GetArea} {
    #if { @ga.IsUnderway{} }                    {dbgLog map underway; #return};
    #if { "$gMapRoom[direction]" != "here" }    {dbgLog map not here; #return};

    map.area.check;
};

///=== {
// #@ map.GetArea
//    返回当前房间信息中的区域信息。无参数。
// };
#func {map.GetArea} {
    #return {@map.resolveArea{$gMapRoom[area]}};
};

#alias {map.area.check} {
    #local stage {@default{{%1};start}};

    #local area {@map.GetArea{}};
    #if { "$area" != "" } {
        #if { "$gMapRoom[area][RESOLVED]" == "" } {
            #var gMapRoom[area][RESOLVED] {$area};
            event.DelayEmit map/GotArea;
        };
        #return;
    };

    #switch {"$stage"} {
        #case {"start"} {
            event.HandleOnce {map/GotNodeInfo} {map/area} {map} {map.area.check walk-done};
            map.GetNodeInfo gag;
        };
        #case {"walk-done"} {
            event.HandleOnce {map/GotLocalmaps} {map/area} {map} {map.area.check localmaps-done};
            map.Localmaps gag;
        };
        #case {"localmaps-done"} {
            #return;
        };
    };
};

///=== {
// ## map.Localmaps <是否 gag> [<命令参数>]
//    执行 localmaps，但因为该命令结果过于刷屏，因此允许 gag 其输出。
// };
#alias {map.Localmaps} {
    #local gag  {%1};
    #local args {%2};

    #if { "$args" != "" } {
        xtt.Send {localmaps $args};
        #return;
    };

    #var gMapRoom[area][LMAP] {};

    #class map.Localmaps open;

    #line oneshot #action {~^{\e\[0m|}%c◆%*地图%*◆%c%s%c$} {
        #local color {%%2};
        #replace color {\e[} {};
        #replace color {m$} {};
        #replace color {m} {;};
        #local area {%%3%%4};
        #var gMapRoom[area][LMAP]   {$area};
        #var gMapRoom[area][COLOR]  {$color};
        #if { "$area" == "柳秀山庄" } {
            #class map.Localmaps.gag kill;
        };
    } {2};

    #line oneshot #action {^%s%S略图%s$} {
        #var gMapRoom[terrain] {@default{$gMapRoom[terrain];随机地图}};
        #var gMapRoom[village] {%%2};
    };

    #line oneshot #action {┌─{(─)*}─%*附近详图─{(─)*}─┐$} {
        #var gMapRoom[terrain] {随机地图};
    };

    #if { "$gag" == "gag" } {
        #class map.Localmaps.gag open;
        #action {^%*{|ID=map/localmaps}$} {#line gag} {6};
        #gag {^%*{|ID=map/localmaps}$};
        #class map.Localmaps.gag close;
    };

    #class map.Localmaps close;

    xtt.Send {localmaps};

    sync.Wait {
        #class map.Localmaps kill;
        #class map.Localmaps.gag kill;
        event.DelayEmit map/GotLocalmaps;
    };
};

#alias {lm}             {map.Localmaps nogag {%0}};
#alias {localmaps}      {map.Localmaps nogag {%0}};
#alias {localmaps_gag}  {map.Localmaps gag {%0}};

#nop 根据数据源确定区域信息。数据源有四种（按使用优先级）：link、walk、node、localmaps;
#func {map.resolveArea} {
    #local source {%0};

    #if { "$source[RESOLVED]" != "" } {
        #return {$source[RESOLVED]};
    };

    #if { "$source[LINK]$source[WALK]$source[NODE]$source[LMAP]" == "" } {
        #return {};
    };

    #local lmap {@default{$source[LMAP];%*}};
    #local pattern {%*/$lmap};

    #nop 如果有 LMAP 的话，先根据 LMAP 检索，这个基本上可以做到一一对应。;
    #if { "$source[LMAP]" != "" } {
        #local keys {@table.Keys{map.area.dict;{$pattern}}};
        #if { @sset.Size{$keys} == 1 } {
            #return {$map.area.dict[$keys][PP]};
        };
    };

    #nop 否则查找与 LINK/WALK/NODE 相匹配的信息。;
    #nop TODO: 理论上这部分也可以做优化，但是 KEY 长了之后太丑了没必要。;
    #local area {};
    #foreach {*map.area.dict[$pattern]} {area} {
        #local area {$map.area.dict[$area]};
        #if { "$source[LINK]" == "%+/%+" } {
            #local link {@str.Replace{{$source[LINK]};%+/%+;{{node}{&1}{links}{&2}}}};
            #if { "$area[LINKS][$link[node]]" === "$link[links]" } {
                #return {$area[PP]};
            };
        };
        #elseif { "$source[WALK]$source[NODE]" != "" } {
            #if { "$source[WALK]$source[NODE]" !== "$area[WALK]$area[NODE]" } {
                #continue;
            };
            #if { "$source[WALK]/$source[NODE]" !== "NOTHING/NOTHING" } {
                #return {$area[PP]};
            };
        };
    };

    #return {};
};

///=== {
/// #@ map.AreaColor <区域名称>
//     获取该区域的颜色。
//     区域颜色是一个区域的固有属性，可以通过该区域的平民 title 的颜色来确认。
// };
#func {map.AreaColor} {
    #local area {%1};

    #local pattern {$area/%*};

    #if { &map.area.dict[$pattern][] != 1 } {
        #return {};
    };

    #foreach {*map.area.dict[$pattern]} {pattern} {
        #return {$map.area.dict[$pattern][COLOR]};
    };
};
